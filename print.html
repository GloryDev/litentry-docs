<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Litentry Documentation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This is official Litentry Documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
                <link rel="stylesheet" href="highlight.css">
                <link rel="stylesheet" href="tomorrow-night.css">
                <link rel="stylesheet" href="ayu-highlight.css">
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/solarized-light.min.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/protocol.html"><strong aria-hidden="true">1.1.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="introduction/tokenEconomy.html"><strong aria-hidden="true">1.2.</strong> Token Economy</a></li><li class="chapter-item expanded "><a href="introduction/architecture.html"><strong aria-hidden="true">1.3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="introduction/privacyData.html"><strong aria-hidden="true">1.4.</strong> Privacy Data Feeding</a></li></ol></li><li class="chapter-item expanded "><a href="runtime/runtime.html"><strong aria-hidden="true">2.</strong> Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/chainStorage.html"><strong aria-hidden="true">2.1.</strong> Chain Storage</a></li><li class="chapter-item expanded "><a href="api/chainExtrinsic.html"><strong aria-hidden="true">2.2.</strong> Chain Extrinsic</a></li><li class="chapter-item expanded "><a href="api/types.html"><strong aria-hidden="true">2.3.</strong> Chain Types</a></li></ol></li><li class="chapter-item expanded "><a href="mobile-app/mobile-app.html"><strong aria-hidden="true">3.</strong> Litentry Authenticator</a></li><li class="chapter-item expanded "><a href="sdk/sdk.html"><strong aria-hidden="true">4.</strong> SDK</a></li><li class="chapter-item expanded "><a href="web-app/web-app.html"><strong aria-hidden="true">5.</strong> Litentry DApp Playground</a></li><li class="chapter-item expanded "><a href="data-server/data-server.html"><strong aria-hidden="true">6.</strong> IPFS Data Center</a></li><li class="chapter-item expanded "><a href="graphql/cache.html"><strong aria-hidden="true">7.</strong> GraphQL Caching Server</a></li><li class="chapter-item expanded "><a href="light-client/light-client-services.html"><strong aria-hidden="true">8.</strong> Light Client Services</a></li><li class="chapter-item expanded "><a href="registrar/HowToVerifyYourIdentity.html"><strong aria-hidden="true">9.</strong> Litentry Registrar</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="registrar/HowToVerifyYourIdentity.html"><strong aria-hidden="true">9.1.</strong> How To Verifiy Your Identity</a></li><li class="chapter-item expanded "><a href="registrar/RegistrarImplementationDetails.html"><strong aria-hidden="true">9.2.</strong> Registrar Implementation Details</a></li></ol></li><li class="chapter-item expanded "><a href="faq/faq.html"><strong aria-hidden="true">10.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Litentry Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/litentry/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Litentry Protocol is helping support change that in favour of a user-centric internet with the blockchain.</strong></p>
<h2 id="concept-of-user-centric-internet"><a class="header" href="#concept-of-user-centric-internet">Concept of User-Centric Internet</a></h2>
<p>As we entrust safe-storage of our passwords and online activity data to third parties on the app-centric internet of today, we are often asked to comply with ambiguous and unfair privacy policies handing over control our own data. As a result our data is often harvested and used in ways we do not have a say in.</p>
<p>Litentry is helping support change that in favor of a user-centric internet with the blockchain. That means the internet should dominant by the users. We decide what services or apps to users, the decision should not limited by the migration cost or specific terms. The profit generated by the user data should go back to user, instead of mainly flows to service provider / companies. </p>
<p>Litentry includes an identity-based network and related tools, as a whole it consists of a decentralized identity authentication and user activity data management infrastructure.</p>
<p>The protocol and network designed at start is not only fits to the internet, but also fits to all the digital services in the real world.</p>
<h2 id="highlights"><a class="header" href="#highlights">Highlights	</a></h2>
<h4 id="blockchain-powered"><a class="header" href="#blockchain-powered">Blockchain Powered:</a></h4>
<p>Litentry is build on Substrate, which inherits great features and best technologies in the Blockchain industry. Litentry aim to be the Parachain of Polkadot Network and benefit from the thriving cross-chain ecosystem and share security.</p>
<h4 id="identity-management"><a class="header" href="#identity-management">Identity Management:</a></h4>
<p>Get back the control of user access history and privacy data generated in the apps or services, user's identities are anonymous and independent from each other.</p>
<h4 id="decentralized-storage"><a class="header" href="#decentralized-storage">Decentralized Storage:</a></h4>
<p>A user is able to store these encrypted identity related data on a decentralized storage like IPFS or Arweave, or on-chain Database. The data is protected by the access control of decentralized storage.</p>
<h4 id="identity-staking"><a class="header" href="#identity-staking">Identity Staking:</a></h4>
<p>With a transparent protocol, an identity owner could stake his identity into identities pool and get regularly reward with data protected. Litentry enable anonymous data matching and permissioned data query. With data protected, Litentry monetize the identity data and benefit identity owner and DApp.</p>
<h4 id="decentralized-ecosystem-contributor"><a class="header" href="#decentralized-ecosystem-contributor">Decentralized Ecosystem Contributor:</a></h4>
<p>Share the identity anonymously between different platforms, a user do not need to create multiple accounts in order to use different services, and prevent these services for building user profile. No password, no registration, no migration barriers. Litentry and decentralized ecosystem benefit each other.</p>
<h2 id="concept-of-decentralization"><a class="header" href="#concept-of-decentralization">Concept of Decentralization</a></h2>
<p>The decentralization of Litentry includes following aspects:</p>
<h4 id="decentralization-of-identity-storage"><a class="header" href="#decentralization-of-identity-storage">Decentralization of identity storage:</a></h4>
<p>User data, including identity credential, should be storage in the a decentralized storage, instead of the central data server of service provider, currently we support IPFS, in the future we will have other storage support like Arwaeve or Litentry native on-chain key-value store. </p>
<h4 id="decentralization-of-identity-authentication"><a class="header" href="#decentralization-of-identity-authentication">Decentralization of identity authentication:</a></h4>
<p>The identity validator connect to the decentralized network periodically, and it could validate the authentication request independently. </p>
<h4 id="decentralization-of-identity-relationships"><a class="header" href="#decentralization-of-identity-relationships">Decentralization of identity relationships:</a></h4>
<p>The relationship of data, and identity could be validated with cryptographic calculation, and it is also record in the decentralized network instead of regular centralized service like Certificate Authority used in HTTPS protocol. Different identities belong to owner are not discoverable, and protected by Schnorr25519 Algorithm. </p>
<h4 id="decentralization-of-identity-data-allocation"><a class="header" href="#decentralization-of-identity-data-allocation">Decentralization of Identity Data Allocation:</a></h4>
<p>The user data generated when using third party applications/services could be processed by the resolver function on Litentry Network, thus provider user a trustworthy data, with allocate data from variant origins, user are able to get valuable user profile like health info, shopping history, etc. </p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<h4 id="user"><a class="header" href="#user">User:</a></h4>
<p>The origin of data, it a person who holds identities or IoT devices.</p>
<h4 id="identity"><a class="header" href="#identity">Identity:</a></h4>
<p>It is a generalized concept of identity, not only include the identity of person, but also any thing could generate claims like IoT devices. A person could own multiple identities, like an identity only related to musics, an identity only for data in Germany, or an identity as a game player. It is an anchor to its related data, the id of it does not have any meaning.</p>
<h4 id="external-data"><a class="header" href="#external-data">External Data:</a></h4>
<p>data generated when using the applications/services and anchored with identity, like the shopping history when a user shopping in e-store, or the age data read from the aforementioned age proving request.</p>
<h4 id="authorization-token"><a class="header" href="#authorization-token">Authorization Token:</a></h4>
<p>A piece of data prove the read or write permission to identity’s external data. Like the permission to read the age data of a person.</p>
<h1 id="protocol"><a class="header" href="#protocol">Protocol</a></h1>
<h3 id="concept-of-decentralization-1"><a class="header" href="#concept-of-decentralization-1">Concept of Decentralization</a></h3>
<p>The decentralization of Litentry includes following aspects:</p>
<ul>
<li>
<p><code>Decentralization of identity storage</code>: User data, including identity credential, should be storage in the user's owned devices, instead of the central data server of service provider.</p>
</li>
<li>
<p><code>Dentralization of idenity authentication</code>: The identity validator connect to the decentralized network periodically, and it could validate the authentication request independently.</p>
</li>
<li>
<p><code>Decentralization of identity ownership</code>: The relationship of data, person, and identity could be validated with cryptographic calculation, and it is also record in the decentralized network instead of regular centralized serviec like Certificate Authority used in HTTPS protocol</p>
</li>
<li>
<p><code>Decentralization of Identity Data Allocating</code>: The user data generated when using third party applications/services could be processed by the resolver function on Litentry Network, thus provider user a trustworthy data, with allocate data from multiple applications/services, user are able to create valuable user profile like health info, shopping history, etc.</p>
</li>
</ul>
<h3 id="definitions-1"><a class="header" href="#definitions-1">Definitions</a></h3>
<ul>
<li><code>User</code>: The origin of data, it a person who holds identities or IoT devices. </li>
<li><code>Identity</code>: It is a generalized concept of identity, not only include the identity of person, but also any thing could generate claims like IoT devices. A person could own multiple identities, like an identity in Germany, an identity as E-Resident in Estonia, or an identity as an game player.</li>
<li><code>Authorization</code>: The permission in the reality or the claim in the blockchain world. It is a piece of data that could prove the ownership to a capability or a real thing. Like the permission to read the age data of a person, or the ownership of a 3D printer on a certain day.</li>
<li><code>External Data</code>: It is the data generated when using the applications/services, like the shopping history when a user shopping in e-store, or the age data read from the aforementioned age proving request.</li>
</ul>
<h3 id="network-interoperability"><a class="header" href="#network-interoperability">Network Interoperability</a></h3>
<p>Based on Substrate Network, Litentry aims to become a fundamental part in the Web3 infrastructure.</p>
<p>// TODO</p>
<ul>
<li><code>Network Layer</code>: Polkadot is here to connect different blockchains</li>
<li><code>Runtime Layer</code>: The Litentry Pallet could be used for other Substrate network builders.</li>
<li><code>Application Layer</code>: Small business could build smart contract on Litentry network.</li>
</ul>
<h1 id="token-economy"><a class="header" href="#token-economy">Token Economy</a></h1>
<h2 id="economy-participants"><a class="header" href="#economy-participants">Economy Participants</a></h2>
<h4 id="identity-staker"><a class="header" href="#identity-staker">Identity Staker:</a></h4>
<p>The users who has an identity record on chain, and has stake the identity into identities pool.</p>
<h4 id="identity-validator"><a class="header" href="#identity-validator">Identity Validator:</a></h4>
<p>After the staking identity of identity staker is confirmed on chain, he will become identity validator for the next few blocks.</p>
<h4 id="external-storage"><a class="header" href="#external-storage">External Storage:</a></h4>
<p>An decentralized storage records all the related data of the identity (Currently IPFS, in the future we may add more database support)</p>
<h4 id="node"><a class="header" href="#node">Node:</a></h4>
<p>The maintainer of the network, it task is to record the state of the network, and respond to data matching queries, sending data access request to external storage, and use off-chain worker to validate the correctness of the identity staking data.</p>
<h4 id="data-buyer"><a class="header" href="#data-buyer">Data Buyer:</a></h4>
<p>An entity have either one of following two types of requirement is data buyer:
Arbitrary identity data: request a matching identity (list) according to the types/requirement data of certain identity: in this case, the buyer will need a authorization token from the identity.</p>
<h4 id="data-origin-data-generator"><a class="header" href="#data-origin-data-generator">Data Origin (Data Generator):</a></h4>
<p>there are three types of data origin:</p>
<ol>
<li>Decentralized services / apps, it generate the data when user interact with dapp is signed by the data generator.</li>
<li>Traditional app / services, they may offer data migration services, it maybe signed or not. If it is signed, and data generator is register on the Litentry network, the data generator also benefits from data queries.</li>
<li>User generate the data by his own.</li>
</ol>
<h2 id="identity-staking-process"><a class="header" href="#identity-staking-process">Identity Staking Process</a></h2>
<h4 id="identity-preparation"><a class="header" href="#identity-preparation">Identity Preparation:</a></h4>
<p>A identity staker who want to stake an identity into identities pool, need first has the required data type and format anchored to this identity, and the data is stored correctly in the External Storage. </p>
<h4 id="identity-data-picking"><a class="header" href="#identity-data-picking">Identity Data Picking:</a></h4>
<p>Then the user chose which kind of the data he want to staked into the pool, only the picked type will be available for data matching, also the more data he chose, the more benefits he get, staker will need also pay a validation fee to the network and a basic staking deposit.</p>
<h4 id="staking-identity-validation"><a class="header" href="#staking-identity-validation">Staking Identity Validation:</a></h4>
<p>The data will be send to random selected identity Validator on chain, identity validator will try to prove if the data is correct. Here is three possibilities:</p>
<ul>
<li>If any one of the validator reject the data, the staking process is failed, and part of thee fee will be returned, validator got no money.</li>
<li>If all validator proved the data, and identity with authorized types will goes into identities pool, fee paid to validator.</li>
<li>Same as above, If all validator proved the data, and identity with authorized types will goes into identities pool. But if in the next 30 block a malicious data is found for this identity, a part of reward of all the approved validator will be slashed, this slashing amount is decided by the existing blocks number (in this case, 30) of the existing malicious data.</li>
</ul>
<h4 id="staking-identity-finalization"><a class="header" href="#staking-identity-finalization">Staking Identity Finalization:</a></h4>
<p>The value of the identity data will be judged by its completeness and its relevance and according type and identity will be stored into on-chain storage. No identity data is stored, afterward each block the identity owner will receive rewards, and the reward is bound to the staking identity until it retire from the identities pool.</p>
<h4 id="staking-identity-retirement"><a class="header" href="#staking-identity-retirement">Staking Identity Retirement:</a></h4>
<p>After certain block, the identity will be retired from the identities pool, after that, the rewards bound to the identity and the deposit will be release. User could update the identity data and then staking it again.</p>
<h2 id="identity-query-process"><a class="header" href="#identity-query-process">Identity Query Process</a></h2>
<p>According to the different data type required by data buyer. There are two types of query</p>
<h3 id="1-matching-query"><a class="header" href="#1-matching-query">1. Matching Query</a></h3>
<h4 id="data-matching-request"><a class="header" href="#data-matching-request">Data Matching Request:</a></h4>
<p>Data buyer require a matching data with selected data type and criteria, which consist of a matching query.</p>
<h4 id="data-matching-pre-making"><a class="header" href="#data-matching-pre-making">Data Matching Pre-Making:</a></h4>
<p>Node in the network will now start generate a list with random picking identities has the required type of data. The length of the list is decided by the fees the data buyer paid, the more data buyer pay, the bigger the list is. And the on-chain randomness make sure each time the result list would be different, so user has motivation to make the query two times.</p>
<h4 id="data-selection"><a class="header" href="#data-selection">Data Selection:</a></h4>
<p>The list is send to the external Storage and the data is send back to the network and is received by the off-chain worker. Now the off-chain worker will use the selection algorithms to get the best suitable identity data for the buyer, and send the result back to user. The match winner will get the most of the fee paid by the buyer, others fee goes to the others in the list and data origin, also Litentry get small part of the fees.</p>
<h3 id="2-target-identity-query"><a class="header" href="#2-target-identity-query">2. Target Identity Query</a></h3>
<h4 id="identity-data-request"><a class="header" href="#identity-data-request">Identity Data Request:</a></h4>
<p>Data buyer require a matching data with selected data type and identity id, the query also include an authorization token signed by the identity owner.</p>
<h4 id="request-validation"><a class="header" href="#request-validation">Request Validation:</a></h4>
<p>Node in the network will check the authorization token issuer, receiver, and validate block number. And finally decide if it is a valid request.</p>
<h4 id="request-finalization"><a class="header" href="#request-finalization">Request Finalization:</a></h4>
<p>A data request event is triggered, the off-chain work start to request the certain data from external storage, once it receive it, it will send a http request back to the data buyer. Fee is all paid to the identity owner and its related data origin, Litentry get a small portion.</p>
<h2 id="incentivization"><a class="header" href="#incentivization">Incentivization</a></h2>
<p>Basics:
LIT is the native token of Litentry Network, each block the network will give a fix amount reward to the identities owner of identities in identities pool.
In the staking finalization process, the value of the staking identity will be quantitated, so that the block stake reward will be shared according to identities staking value.</p>
<h4 id="for-identity-staker"><a class="header" href="#for-identity-staker">For Identity Staker:</a></h4>
<p>The profit of identity staker are from two parts, </p>
<ol>
<li>Block Reward: Once staker data is into identities pool, Identity Staker will get the reward each block. </li>
<li>Matching Fee: Once the matching success with staked identity, the owner will get paid. 
So in the early stage, the matching request are not big enough, the identity staker will mostly benefits from block reward. When the network get more user and become mature, the share of matching fee will more evenly distributed to the quality identity staker. Thus a staker’s main benefit is matching fee.</li>
</ol>
<h4 id="for-identity-validator"><a class="header" href="#for-identity-validator">For Identity Validator:</a></h4>
<p>They are motivated to become Identity Staker, so it is part of the responsibility to validate the correctness of the data.
If the origin of data is generated by the identity itself, then the validator will get reward once the data is used, since the validator has proved the authenticity of the data.</p>
<h4 id="for-dapp-as-data-origin"><a class="header" href="#for-dapp-as-data-origin">For Dapp as Data Origin:</a></h4>
<p>Explicit benefits is the grants from Litentry Foundation, each success match will pay fee back to data origin. Implicit Benefits are: It is a new way to attract new users since users could harvest their own data. And for user from other DApp, there is no migration cost, they have motivate to make innovation instead building business protections.</p>
<h4 id="for-node"><a class="header" href="#for-node">For Node:</a></h4>
<p>As the network maintainer, they will get native token reward from the network.</p>
<h4 id="for-external-storage"><a class="header" href="#for-external-storage">For External Storage:</a></h4>
<p>User pays their own storage fee to the external storage, so they are willing to provide their services to our network.</p>
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<h3 id="the-protocol-is-mainly-constructed-with-following-parts"><a class="header" href="#the-protocol-is-mainly-constructed-with-following-parts">The protocol is mainly constructed with following parts:</a></h3>
<ul>
<li><a href="introduction/../runtime/runtime.html">Litentry Runtime</a></li>
<li><a href="introduction/../mobile-app/mobile-app.html">Litentry Authenticator Mobile App</a></li>
<li><a href="introduction/../web-app/web-app.html">Litentry DApp Playground</a></li>
<li><a href="introduction/../">Litenry IPFS Data Center</a></li>
<li><a href="introduction/../sdk/sdk.html">Litentry SDK</a></li>
<li><a href="introduction/../api/api.html">Litentry GraphQL Caching Server</a></li>
</ul>
<p><img src="introduction/./design.png" alt="API Design" /></p>
<p>Other than web 2.0 architectures, we are suppose to build a decentralized ecosystem with Blockchain as backend services than cloud or single node server.</p>
<h3 id="runtime"><a class="header" href="#runtime">Runtime</a></h3>
<p>Litentry Runtime is built with Substrate, it inherits great features and best technologies in the industry. </p>
<p>We use offchain worker to generate identity related data, and thus remove the uncertain and privacy issue by the client side applications.</p>
<p>We aim to be the Parachain of Polkadot Network. We will also benefit from the thriving cross-chain ecosystem.</p>
<h3 id="user-side"><a class="header" href="#user-side">User Side</a></h3>
<p>User has full control of identity data, data generated from Apps flows to user's decentralized storage like IPFS or Arweave. User's identities are anonymous, cryptographic separated.</p>
<h4 id="litentry-authenticator"><a class="header" href="#litentry-authenticator">Litentry Authenticator</a></h4>
<p>On user side we have Litentry Authenticator as user's mobile data hub.</p>
<p>Personal users would like to use an application to manage all its identities, it could also become a Hub connected to different interest IoT devices. For example, directly buying the authorization or the data from other IoT devices. With the advantage of GPS of mobile phone, it could further integrate with LBS (Location Based Services).</p>
<p>In order to work in a fully decentralized scenario, itself also need to integrate a cold wallet, where could keep a user's private key in a secure environment provided by Android or iOS.</p>
<h4 id="dapps-build-with-litentry-protocol"><a class="header" href="#dapps-build-with-litentry-protocol">DApps build with Litentry Protocol</a></h4>
<p>With Litentry SDK, developers could easily build fully decentralized Apps or Services. User could directly signin without password, without registration. Simply with Cryptographic QR code. App could use IPFS, Arweave or even on-chain key value database for storing user data, instead of storing data on backend server.</p>
<p>By this we are convert to an app-centric internet to a user-centric one.</p>
<h4 id="litentry-ipfs-data-center"><a class="header" href="#litentry-ipfs-data-center">Litentry IPFS Data Center</a></h4>
<p>Litentry uses OrbitDB to offer an IPFS database support. In Data Center, user may check their identity related data and tokens.</p>
<p>In the future we will implement Arweave and on-Chain key value storage.</p>
<h3 id="middleware-layer"><a class="header" href="#middleware-layer">Middleware Layer</a></h3>
<p>It mainly includes:</p>
<ul>
<li>
<p>Event listener and off-chain caching server:  With cached data it reduces the query load on the blockchain, furthermore, it saves the caching data on the centralized database in order to improve the speed of application-based blockchain query, like Infura for Ethereum. A relay script server is also built here, to automatically trigger an event on periodically regarding block generation.</p>
</li>
<li>
<p>GraphQL caching server: Since IPFS is still under testing, we currently use graphql caching server to improve user experience for sync the data, it also caching anonymous data, and improve data query speed.</p>
</li>
<li>
<p>Validation and query server: validate the authorization tokens with HTTPS request for IoT devices or application.</p>
</li>
<li>
<p>Client side SDK library: The javascript binding library will directly connect the front-end applications with Blockchain, for example, React or React Native applications.</p>
</li>
</ul>
<h1 id="privacy-data-feeding-and-protection"><a class="header" href="#privacy-data-feeding-and-protection">Privacy data feeding and protection</a></h1>
<p>The current verification process has problems of privacy data generation.</p>
<ol>
<li>
<p>If a user come to Hotel with his digital key (claim). The smart lock itself could generate data, and each time user come into the room, these pieces of data is generated, but they are harvested by the hotel, and never reach to user.</p>
</li>
<li>
<p>The Data generated are combined with user's accountID (public address), when these authorizations (claims) be more enough, it will be practical for the external companies to monitor the on-chain state, and build user profile.</p>
</li>
</ol>
<p>To resolve this problem, and let the user get their data, we have designed our new method based on Substrate offline worker and crypto algorithms based on Schnorr25519.</p>
<ol>
<li>
<p>To protect user's data, we migrate the data generation process on to Substrate, after the verification process, the crucial arguments like user address, verifier, time, token hash will be send into blockchain with a <code>verifier</code> extrinsic. Which is independent with off-line verification, thus it will not affect the verification time. Then the data will be generated in offchain worker, generate access token to user's storage, and then feed the data back to user.</p>
</li>
<li>
<p>To protect the user data, we will use HDKD feature to periodically generate new soft derivated key pairs for certain user. Verifier could prove the the address is belongs to the parent keypairs with crypto algorithms.  Thus user will not need to always show one certain public address. Another key point is to use ring signature, which will hide user's signature behind bunch of people.   Child address generation feature is already implemented in our crypto wallet and Ring signature is our current experiment direction.</p>
</li>
</ol>
<p>The workflow of user data feed could be seen in the following diagram</p>
<p><img src="introduction/./dataFeed.png" alt="User Data Feed Diagram" /></p>
<p>Related Article about Off-Chain Worker: <a href="https://www.parity.io/substrate-off-chain-workers-secure-and-efficient-computing-intensive-tasks/">https://www.parity.io/substrate-off-chain-workers-secure-and-efficient-computing-intensive-tasks/</a></p>
<h1 id="runtime-1"><a class="header" href="#runtime-1">Runtime</a></h1>
<p>Github Repository: <a href="https://github.com/litentry/litentry-node">https://github.com/litentry/litentry-node</a></p>
<p>There are two pallets from litentry both account-linker and offchain-worker.</p>
<p><a href="https://github.com/litentry/litentry-node/blob/develop/pallets/account-linker/src/lib.rs">https://github.com/litentry/litentry-node/blob/develop/pallets/account-linker/src/lib.rs</a></p>
<p><a href="https://github.com/litentry/litentry-node/blob/develop/pallets/offchain-worker/src/lib.rs">https://github.com/litentry/litentry-node/blob/develop/pallets/offchain-worker/src/lib.rs</a></p>
<h3 id="abstract"><a class="header" href="#abstract">Abstract</a></h3>
<p>The identity runtime protocol link the all cross chain accounts to make an unique Litentry Identity. After accounts linked, Litentry user can trigger the asset claim via transaction. Litentry offchain worker will query your assets in other blockchain network, generate asset prove on-chain. Any Defi or other Dapp can use the information for their service:</p>
<ol>
<li>
<p>Account Linking: Litentry user sign the specific data with private key.</p>
</li>
<li>
<p>Asset Claim: Litentry user ask runtime to query its asset and generate prove.</p>
</li>
<li>
<p>Defi or other Dapp: Use the Litentry ID and its assets prove for their service. </p>
</li>
</ol>
<h3 id="stakeholders"><a class="header" href="#stakeholders">Stakeholders</a></h3>
<ol>
<li>Litentry user: They register into Litentry network, can get the token incentive if their data queried by DeFi or other Dapps. Their information is protected with encryption and used in a secure runtime environment. </li>
<li>Defi: Litentry user's ID and their assets prove is critical factor to determine their financial service. </li>
<li>Dapps: Litentry user's cross chain information includes all activities in the whole cryptocurrency world. Litentry is the unique and unified entry point for their service.</li>
<li>Litentry node runner: Except get the block produce incentive, they can also run offchain worker for cross chain asset query service. They will be rewarded if the query result they submitted is correct.</li>
</ol>
<h3 id="scenario"><a class="header" href="#scenario">Scenario:</a></h3>
<h5 id="defi"><a class="header" href="#defi">Defi:</a></h5>
<ul>
<li>
<p>Identity Registry: Litentry register and get Litentry ID with LIT token;</p>
</li>
<li>
<p>Asset claim: If Litentry user also own assets in Bitcoin and Ethereum, they can link their account in Bitcoin and Ethereum at first. Then require Litentry to query their balance and create asset prove;</p>
</li>
<li>
<p>Defi service: Litentry provide the SDK and API for Defi application, Defi can access Litentry ID and assets prove.Base on these information, Difi can put in into their algorithm model, then decide the loan amount, interests and credits score.</p>
</li>
</ul>
<h5 id="cross-chain-identity"><a class="header" href="#cross-chain-identity">Cross Chain Identity:</a></h5>
<ul>
<li>
<p>Identity Registry: Litentry register and get Litentry ID with LIT token;</p>
</li>
<li>
<p>Dapp: Dapp service can get the aggregated cross chain account information via Litentry Id. Then Dapp can avoid implement every API for different blockchain network;</p>
</li>
</ul>
<h5 id="smart-contract-with-credit-score-algorithm"><a class="header" href="#smart-contract-with-credit-score-algorithm">Smart contract with credit score algorithm:</a></h5>
<ul>
<li>
<p>Identity Registry: Litentry register and get Litentry ID with LIT token;</p>
</li>
<li>
<p>Smart contract: Litentry runtime provide raw data to smart contract deployed in Litentry network. Different smart contract can use diverse algorithm to compute the credits score. The applications can use one smart contract's data or use data source from different smart contracts to get their customer's financial profile.</p>
</li>
</ul>
<h2 id="in-the-future"><a class="header" href="#in-the-future">In the future</a></h2>
<p>The Litentry runtime is under very active development now. More pallets will be implemented and integrated into Litentry runtiime. Litentry network will acquire the slot of both Kusama and Polkadot. Cross chain ID aggregation and query will be realized.</p>
<h1 id="chain-state-storage"><a class="header" href="#chain-state-storage">Chain State Storage</a></h1>
<h4 id="identity-related"><a class="header" href="#identity-related">Identity Related</a></h4>
<pre><code class="language-rust ignore">Identities: T::Hash =&gt; IdentityOf&lt;T&gt;;
IdentityOwner: T::Hash =&gt; Option&lt;T::AccountId&gt;;

IdentitiesCount: u64;
IdentitiesArray: u64 =&gt; T::Hash;
IdentitiesIndex: T::Hash =&gt; u64;

OwnedIdentitiesCount: T::AccountId =&gt; u64;
OwnedIdentitiesArray: (T::AccountId, u64) =&gt; T::Hash;
OwnedIdentitiesIndex: T::Hash =&gt; u64;
</code></pre>
<h4 id="token-related"><a class="header" href="#token-related">Token Related</a></h4>
<pre><code class="language-rust ignore">AuthorizedTokens: T::Hash =&gt; AuthorizedTokenOf&lt;T&gt;;
AuthorizedTokenOwner: T::Hash =&gt; Option&lt;T::AccountId&gt;;
AuthorizedTokenIdentity: T::Hash =&gt; Option&lt;T::Hash&gt;;

AuthorizedTokensCount: u64;
AuthorizedTokensArray: u64 =&gt; T::Hash;
AuthorizedTokensIndex: T::Hash =&gt; u64;

OwnedAuthorizedTokensCount: T::AccountId =&gt; u64;
OwnedAuthorizedTokensArray: (T::AccountId, u64) =&gt; T::Hash;
OwnedAuthorizedTokensIndex: T::Hash =&gt; u64;

IdentityAuthorizedTokensCount: T::Hash =&gt; u64;
IdentityAuthorizedTokensArray: (T::Hash, u64) =&gt; T::Hash;
IdentityAuthorizedTokensIndex: T::Hash =&gt; u64;
</code></pre>
<h1 id="extrinsic"><a class="header" href="#extrinsic">Extrinsic</a></h1>
<h4 id="issuetoken"><a class="header" href="#issuetoken">issueToken</a></h4>
<pre><code class="language-rust ignore">fn issueToken(to, identity_id, cost, data, datatype, expired)
</code></pre>
<p>Issue a token of an owned identity to certain account.</p>
<ul>
<li><code>to</code>: Hash, the receiver identity id</li>
<li><code>identity_id</code>: Hash, the issuer identity id </li>
<li><code>cost</code>: Balance, the transfer cost of the token</li>
<li><code>data</code>: byte, The data stored in the token</li>
<li><code>data_type</code>: byte, the type of the data represent in byte</li>
<li><code>expired</code>: byte, which define the expired date of the token</li>
</ul>
<h4 id="registeridentity"><a class="header" href="#registeridentity">registerIdentity</a></h4>
<pre><code class="language-rust ignore">fn registerIdentity()
</code></pre>
<p>Register a new identity for this account.</p>
<h4 id="registeridentitywithid"><a class="header" href="#registeridentitywithid">registerIdentityWithId</a></h4>
<pre><code class="language-rust ignore">fn registerIdentityWithId(identity_id)
</code></pre>
<p>Register a new Identity with existed identifier as Identity ID, this is useful when register a third party devices or services. For example, a user buy a new IoT camera, there could already exist a identifier on the back of device reserved for the buyer.</p>
<ul>
<li><code>identity_id</code>: Hash, the identifier to be used as identity ID</li>
</ul>
<h4 id="transfertoken"><a class="header" href="#transfertoken">transferToken</a></h4>
<pre><code class="language-rust ignore">fn transferToken(to, token_id)
</code></pre>
<p>Transfer a owned token to another account</p>
<ul>
<li><code>to</code>: AccountId, the future owner of the token</li>
<li><code>token_id</code>: Hash, the ID of the transferred token</li>
</ul>
<h1 id="types"><a class="header" href="#types">Types</a></h1>
<pre><code class="language-json">{
  &quot;Address&quot;: &quot;AccountId&quot;,
  &quot;LookupSource&quot;: &quot;AccountId&quot;,
  &quot;IdentityOf&quot;: {
    &quot;id&quot;: &quot;Hash&quot;
  },
  &quot;AuthorizedTokenOf&quot;: {
    &quot;id&quot;: &quot;Hash&quot;,
    &quot;cost&quot;: &quot;Balance&quot;,
    &quot;data&quot;: &quot;u64&quot;,
    &quot;datatype&quot;: &quot;u64&quot;,
    &quot;expired&quot;: &quot;u64&quot;
  }
}
</code></pre>
<p>When using with Polkadot.js App you will need to addthe above Litentry's types so it can encode and decode the extrinsic correctly, copy the following code to the text field on &quot;developer&quot; tabs: https://polkadot.js.org/apps//#/settings/developer .</p>
<p><img src="api/./useWithAPI.png" alt="Example on Overwrite Types on Polkadot Apps" /></p>
<h1 id="authentication-mobile-app"><a class="header" href="#authentication-mobile-app">Authentication Mobile App</a></h1>
<p>Github Repository: <a href="https://github.com/litentry/litentry-authenticator">https://github.com/litentry/litentry-authenticator</a></p>
<p>Download Litentry Authenticator v1.1.1 from <a href="https://play.google.com/store/apps/details?id=com.litentryauthenticator">Android App Store</a></p>
<h3 id="mobile-app-abstract"><a class="header" href="#mobile-app-abstract">Mobile App Abstract</a></h3>
<p>Personal users would like to use an Wallet Application to manage all its identities, it could also become a Hub connected to different interest IoT devices. For example, directly buying the authorization or the data from other IoT devices. With the advantage of GPS of mobile phone, it could further integrate with LBS (Location Based Services).</p>
<p>In order to work in a fully decentralized scenario, itself also need to integrate a light client, where could keep a user's private key in a secure environment provided by Android or iOS.</p>
<p>Mobile Application Screenshots:</p>
<p>For the step to step guide on use Litentry Authenticator please refer to <a href="https://www.litentry.com/post/play-litentry-dapps-with-ipfs-part-1">this article</a>.</p>
<h4 id="recover-seed-and-manage-account"><a class="header" href="#recover-seed-and-manage-account">Recover Seed and Manage Account</a></h4>
<p><img src="mobile-app/./app1.png" alt="Identity and Token Creation Example" /></p>
<h4 id="register-identity-and-2fa-authentication"><a class="header" href="#register-identity-and-2fa-authentication">Register Identity and 2FA Authentication</a></h4>
<p><img src="mobile-app/./app2.png" alt="Register Identity" /></p>
<h4 id="check-token-related-data"><a class="header" href="#check-token-related-data">Check Token Related Data</a></h4>
<p><img src="mobile-app/./app3.png" alt="Check Token Data" /></p>
<h1 id="litentry-sdk"><a class="header" href="#litentry-sdk">Litentry SDK</a></h1>
<p>Github Repository: <a href="https://github.com/litentry/litentry-sdk">https://github.com/litentry/litentry-sdk</a></p>
<p>This library provides useful functions to interact with the state on Litentry and user identity data related IPFS Storage.</p>
<p>It helps developer to build client side decentralized applications</p>
<h2 id="getting-start"><a class="header" href="#getting-start">Getting Start</a></h2>
<pre><code class="language-ignore">yarn add litentry-sdk
</code></pre>
<p>Import for start using it, SDK mainly includes three part, <code>hooks</code>, <code>query</code> and <code>ipfsApi</code></p>
<pre><code class="language-typescript">import {hooks, query, ipfsApi} from 'litentry-sdk';
</code></pre>
<h2 id="react-hooks-for-litentry"><a class="header" href="#react-hooks-for-litentry">React Hooks for Litentry</a></h2>
<pre><code class="language-typescript ignore">//Api loading State
hooks.useApi(): boolean

//Get Identities, use updatedIndex to force refresh
hooks.useIdentities(account: string, updateIndex: number): string[]

//Get Identity current owned tokens
hooks.useTokens(identityHash: string): string[]

//Get the owner of the token 
hooks.useTokenOwner(tokenHash: string): string

//Get account balance of LTT 
hooks.useBalance(account: string): string

//Help async function for query issuer Identity of the token
hooks.getTokenIdentity(tokenHash: string): Promise&lt;string&gt;]

//Help async function for getting the last issued identity
hooks.getLastIdentity(account: string): Promise&lt;string | void&gt;

// react hooks for using native extrinsics on Litentry
hooks.useExtrinsics(): {
  	registerIdentity: SubmittableExtrinsicFunction&lt;'promise'&gt;;
  	issueToken: SubmittableExtrinsicFunction&lt;'promise'&gt;;
}

</code></pre>
<h2 id="identity-data-query"><a class="header" href="#identity-data-query">Identity Data Query</a></h2>
<p>Identity data are stored in the IPFS network and cached in Litentry GraphQL data server. </p>
<p>functions to query the latest data on IPFS:</p>
<pre><code class="language-typescript">ipfsApi.getAddress(identity: string): Promise&lt;string | null&gt;

ipfsApi.getData(identityId: string): Promise&lt;string[]&gt;

ipfsApi.registerIdentity(identity: string): void
</code></pre>
<p>functions to construct query http request  from GraphQL:</p>
<pre><code class="language-typescript">query.getData(identity: string): string

query.setData(identity: string, data: string): string

query.method(methodName: string, identity: string): string 
</code></pre>
<h1 id="litentry-dapp-playground"><a class="header" href="#litentry-dapp-playground">Litentry DApp Playground</a></h1>
<p>live site on <a href="https://dapp.litentry.com/">https://dapp.litentry.com/</a></p>
<p>Repository: <a href="https://github.com/litentry/litentry-web">https://github.com/litentry/litentry-web</a></p>
<p>On how to start with Litentry DApp Playground please refer to <a href="https://www.litentry.com/post/play-litentry-dapps-with-ipfs-part-1">this article</a>.</p>
<p>Litentry Playground is a hub of decentralized web app applications to achieve a Substrate based authentication.</p>
<p>User could use DAPPs with Litentry decentralized 2FA mobile App. No registration, no password, no App migration barriers.</p>
<p>More about the Authentication (Sign in Process):</p>
<h4 id="the-object-of-litentry-authentication"><a class="header" href="#the-object-of-litentry-authentication">The Object of Litentry Authentication</a></h4>
<ul>
<li>It should allow users to use his/her owned Substrate account related identity to login to a third party website (that supports this login method).</li>
<li>It should be easy to use and reasonably easy to setup.</li>
<li>It should not compromise the security of the user's Substrate account.</li>
<li>It should allow users to recover their credentials in case of loss or theft.</li>
<li>It should not require knowledge of Cryptography or Blockchain with authentication.</li>
<li>It should have reasonable latency for a login system.</li>
<li>It should not cost users gas (or money) to login.</li>
<li>It should be reasonably easy for developers to implement in their apps.</li>
</ul>
<h4 id="the-implementation-of-litentry-authentication"><a class="header" href="#the-implementation-of-litentry-authentication">The Implementation of Litentry Authentication</a></h4>
<ol>
<li>User on a third party website and click login with Litentry Button</li>
<li>A preset account will come if user has logged before in the computer, or a QR scanner comes out for user to scan his/her Substrate account QR code.</li>
<li>At this time the third party website send a transaction to Litentry network with a challenge string and its receiver server address. And sign a JWT with challenge and server address embedded in it.</li>
<li>User now has to open the mobile app (best integrated with Substrate light client), it has watched the event of the auth request, and then sign the JWT with its private key and then send the signed double signed JWT to the server address.</li>
<li>The server proved the token received by the user and then finish the logging process.</li>
<li>After the usage of the third party web application or service, third party allocated the user browsing data/history and query the user's data resolver address, then user data is send back to the resolver and being process and harvested into user's own database.</li>
</ol>
<h4 id="sign-in-to-dapp-playground"><a class="header" href="#sign-in-to-dapp-playground">Sign in to DApp Playground</a></h4>
<p><img src="web-app/./web1.png" alt="Sign in" /></p>
<h4 id="star-songs-in-dspotify-app"><a class="header" href="#star-songs-in-dspotify-app">Star Songs in dSpotify App</a></h4>
<p><img src="web-app/./web2.png" alt="star songs" /></p>
<h4 id="record-mood-with-dtwitter-app"><a class="header" href="#record-mood-with-dtwitter-app">Record mood with dTwitter App</a></h4>
<p><img src="web-app/./web3.png" alt="record mood" /></p>
<h1 id="litentry-ipfs-data-center-1"><a class="header" href="#litentry-ipfs-data-center-1">Litentry IPFS Data Center</a></h1>
<p>Github Repository: <a href="https://github.com/litentry/litentry-ipfs-data-center">https://github.com/litentry/litentry-ipfs-data-center</a></p>
<p>Live Site on <a href="https://data.litentry.com/">https://data.litentry.com/</a></p>
<p>Litentry uses OrbitDB to offer an IPFS database support. In Data Center, user may check their identity related data and tokens.</p>
<p>In the future we will implement Arweave and on-Chain key value storage.</p>
<p><img src="data-server/./dataServer1.png" alt="IPFS Data Server" /></p>
<h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p><a href="graphql/dataServer.html">API of data server</a></p>
<p>Live Server: <a href="https://graphql.litentry.com:4000/playground">https://graphql.litentry.com:4000/playground</a></p>
<p>Github Repository: <a href="https://github.com/litentry/litentry-ipfs-graphql">https://github.com/litentry/litentry-ipfs-graphql</a></p>
<p>Currently, we provide a GraphQL caching server for recording event on the Litentry blockchain and caching data from IPFS.</p>
<p>IPFS is still under testing, graphql caching server could improve user experience for sync the data, it also caching anonymous data, and improve data query speed. </p>
<p><img src="graphql/./graphql1.png" alt="Graphql Server" /></p>
<p>Query types</p>
<pre><code class="language-typescript ignore">  type Record {
    ${recordKey}: String
  }

  type Query {
    registerIdentity(identityId: String): String
    determineAddress(identityId: String): String
    addData(identityId: String, data: String): String
    addDataAddress(address: String, data: String): String
    getData(identityId: String): [Record]
  }
</code></pre>
<p>Example for query <code>playgroundRecord</code> data of certain identity</p>
<pre><code class="language-ignore">https://graphql.litentry.com:4000/graphql?query={getData(identityId:&quot;0x992c710c7fba11ccd22a2fbfec1af6ea85d488807e63e10cbbd16256fcf95752&quot;){playgroundRecord}}
</code></pre>
<p>query IPFS address of certain identity</p>
<pre><code class="language-ignore">https://graphql.litentry.com:4000/graphql?query={determineAddress(identityId:&quot;0x992c710c7fba11ccd22a2fbfec1af6ea85d488807e63e10cbbd16256fcf95752&quot;)}
</code></pre>
<h1 id="light-client-services"><a class="header" href="#light-client-services">Light Client Services</a></h1>
<h3 id="concept"><a class="header" href="#concept">Concept</a></h3>
<p>Light Client should support all the networks on Substrate, and each of them have a node, so we should not pre-package all the nodes into the App, but support the app to download the most recent binary files and save them into the app. It should have at least “chose network”, “start service”, and “stop service” button. And most of the time it should be running in the background and work as an iinterface for all the apps to interact with a certain network.</p>
<p>In addition to giving apps a decentralized feature that talk to the network. An app could register an event subscribing on the light client service and push notifications to the user. So that the notification does not need to go through Android’s or Apple’s message center. A challenge would be how to always keep the light client app alive,  and when the user powered off the phone, the light client would stop receiving messages (a breakpoint resume function could be implemented for the user to get events from the last fetched block).</p>
<h4 id="android-implementation"><a class="header" href="#android-implementation">Android Implementation</a></h4>
<p>The binary could successfully be compiled with the guide here and runned on Android Devices. </p>
<p>To keep the light client always living in the background, we need to use Service, but the policy changed from time to time.</p>
<p>a minimal implementation: <a href="https://github.com/hanwencheng/LightClientServices">https://github.com/hanwencheng/LightClientServices</a>, which supports users to download the binary of Flaming Fir, and run the service in the background.</p>
<h1 id="how-to-verify-your-identity"><a class="header" href="#how-to-verify-your-identity">How To Verify Your Identity</a></h1>
<p>Litentry Registrar Support:  <a href="https://app.element.io/#/room/#litentry-registrar-support:matrix.org">Element Room</a> or <a href="mailto:registrar-support@litentry.com">registrar-support@litentry.com</a></p>
<p>Litentry Registrar index on Kusama is 4, and the service fee is 0.04KSM.</p>
<p><strong>In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg).</strong></p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The user's account (public key, wallet address) on the blockchain can remain anonymous since it is loosely connected with the user's identity. However, a user with high reputation can be trusted by the community in the Polkadot ecosystem when he plans to be a validator or a councilor. In this document, we want to introduce a registrar service that focuses on automatic verifications, leveraging well-designed cryptographical challenges to further reduce human interventions. At the moment, Litentry registrar focuses on providing judgment with confidence for a user's <code>display name</code>, <code>email</code>, <code>twitter</code>, or <code>element name (previously called riot)</code>.</p>
<h2 id="user-interaction"><a class="header" href="#user-interaction">User Interaction</a></h2>
<p>In this section, we will introduce the user's identity verification process step by step. Firstly, users need to set their identity information on the chain. Then, they can request a registrar to provide identity judgment. Users declare a maximum fee and the registrar they are willing to pay and verify for the judgment. After that, the dedicated registrar can ascertain.</p>
<h3 id="setting-an-on-chain-identity"><a class="header" href="#setting-an-on-chain-identity">Setting an On-chain Identity</a></h3>
<p>Go to the Accounts page in Polkadot-JS Apps <a href="https://polkadot.js.org/">Polkadot-JS Apps</a>. The easiest way to add the built-in fields is to click the vertical three dots next to one's account and select &quot;Set on-chain identity&quot;.</p>
<p align="center">
<img src="registrar/./registrar1.png" alt="litentryReggistrar" width="75%" /></p>
<p align="center">Figure 1.1  Set Onchain Identity
</p>
<p>A popup will appear, offering the default fields.
Currently, Litentry registrar only supports the following fields:</p>
<ul>
<li><code>display name</code></li>
<li><code>email</code></li>
<li><code>twitter</code></li>
<li><code>element (formerly known as riot)</code></li>
</ul>
<p>**In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg).Otherwise, they cannot receive the message from the Litentry registrar. **</p>
<p align="center">
<img src="registrar/./registrar2.png" alt="litentryReggistrar" width="60%" /></p>
<p align="center">Figure 1.2  Set Identity
</p>
<p>Once users have filled in the information, they would like to store on-chain, click <code>Set Identity</code> to submit the transaction.</p>
<p>Now Users have set the identity information on-chain, but that is not verified yet, so they should see a little gray icon beside users name. </p>
<p align="center">
<img src="registrar/./registrar3.png" alt="litentryReggistrar" width="40%" height="40%"/></p>
<p align="center">Figure 1.3 Account Example</p>
<p>It is the time to interact with the Litentry's verification bot by submitting the judgment request to the Litentry Registrar.</p>
<h3 id="judgement-request"><a class="header" href="#judgement-request">Judgement Request</a></h3>
<p>Go to Developer-&gt;Extrinsic and select your account to submit the identity -&gt; requestJudgement(reg_index, max_fee) transaction. This will request the registrar to validate the information you set on-chain earlier. The reg_index is the index of the registrar. For Litentry, use 4. The max_fee is the amount KSM to pay the registrar. Litentry Registrar service fee is 0.04 KSM.</p>
<p align="center">
<img src="registrar/./registrar5.png" alt="litentryReggistrar" width="75%" /></p>
<p align="center">Figure 1.4 Judgement request</p></center>
<h3 id="verification-services"><a class="header" href="#verification-services">Verification Services</a></h3>
<p>Since we provide the Email, Element and Twitter verification in our registrar at this moment, you will receive verification requests from those platforms. </p>
<h4 id="email-verification"><a class="header" href="#email-verification">Email Verification</a></h4>
<p>Users will receive an email called &quot;Litentry Verification Service&quot;. Figure 1.5 is an example of email verification. Users only need to click the button &quot;Verify Email Now&quot; to complete proof of email address. Then they will receive another confirmation email that shows the email has been verified successfully.</p>
<p align="center">
<img src="registrar/./email.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.5 Email Verification Example
</p>
<h4 id="element-verification"><a class="header" href="#element-verification">Element Verification</a></h4>
<p>As for Element, an invitation will be sent from the bot named &quot;litentry-bot&quot;. Once the user accepts the invitation, &quot;litentry-bot&quot; will send a verification link. Users only need to click the link to complete verification of the element account. When it proves the user is the account owner, they will receive a confirmation message such as &quot;Verified successfully&quot; (see the figure below). </p>
<p align="center">
<img src="registrar/./riot.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.6 Element Verification Example
</p>
<h4 id="twitter-verification"><a class="header" href="#twitter-verification">Twitter Verification</a></h4>
<p>In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg). Users could also set their accounts to receive any private conversation in their privacy settings. Otherwise, they cannot receive the message from the Litentry registrar. 
Litentry Registrar will send a direct message associated with a verification link to the user. Once the verification link is clicked, 
the verification of Twitter is completed, and you should receive a successful verification message. The following figure is an example of the Twitter account verification process.</p>
<p align="center">
<img src="registrar/./twitter.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.7 Twitter Verification Example
</p>
<p>If everything has been verified successfully, you would see your account verification status has been marked as &quot;reasonable&quot; with a green tick icon on the account. And congratulations! Your identity should now show as a green &quot;verified&quot; checkmark on Polkadot-JS Apps.</p>
<h2 id="registrar-fee"><a class="header" href="#registrar-fee">Registrar Fee</a></h2>
<p>It is important to notice that no KSM are sent to the registrar at any time. You should NOT send or transfer funds. When calling the requestJudgement, the registrar fee will be locked and put aside. It will be transferred to the registrar only after the registrar finishes the judgment job. After all, we are using a trustless system. The judgement fee of Litentry Registrar is 0.04KSM.</p>
<h1 id="how-to-verify-your-identity-1"><a class="header" href="#how-to-verify-your-identity-1">How To Verify Your Identity</a></h1>
<p>Litentry Registrar Support:  <a href="https://app.element.io/#/room/#litentry-registrar-support:matrix.org">Element Room</a> or <a href="mailto:registrar-support@litentry.com">registrar-support@litentry.com</a></p>
<p>Litentry Registrar index on Kusama is 4, and the service fee is 0.04KSM.</p>
<p><strong>In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg).</strong></p>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>The user's account (public key, wallet address) on the blockchain can remain anonymous since it is loosely connected with the user's identity. However, a user with high reputation can be trusted by the community in the Polkadot ecosystem when he plans to be a validator or a councilor. In this document, we want to introduce a registrar service that focuses on automatic verifications, leveraging well-designed cryptographical challenges to further reduce human interventions. At the moment, Litentry registrar focuses on providing judgment with confidence for a user's <code>display name</code>, <code>email</code>, <code>twitter</code>, or <code>element name (previously called riot)</code>.</p>
<h2 id="user-interaction-1"><a class="header" href="#user-interaction-1">User Interaction</a></h2>
<p>In this section, we will introduce the user's identity verification process step by step. Firstly, users need to set their identity information on the chain. Then, they can request a registrar to provide identity judgment. Users declare a maximum fee and the registrar they are willing to pay and verify for the judgment. After that, the dedicated registrar can ascertain.</p>
<h3 id="setting-an-on-chain-identity-1"><a class="header" href="#setting-an-on-chain-identity-1">Setting an On-chain Identity</a></h3>
<p>Go to the Accounts page in Polkadot-JS Apps <a href="https://polkadot.js.org/">Polkadot-JS Apps</a>. The easiest way to add the built-in fields is to click the vertical three dots next to one's account and select &quot;Set on-chain identity&quot;.</p>
<p align="center">
<img src="registrar/./registrar1.png" alt="litentryReggistrar" width="75%" /></p>
<p align="center">Figure 1.1  Set Onchain Identity
</p>
<p>A popup will appear, offering the default fields.
Currently, Litentry registrar only supports the following fields:</p>
<ul>
<li><code>display name</code></li>
<li><code>email</code></li>
<li><code>twitter</code></li>
<li><code>element (formerly known as riot)</code></li>
</ul>
<p>**In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg).Otherwise, they cannot receive the message from the Litentry registrar. **</p>
<p align="center">
<img src="registrar/./registrar2.png" alt="litentryReggistrar" width="60%" /></p>
<p align="center">Figure 1.2  Set Identity
</p>
<p>Once users have filled in the information, they would like to store on-chain, click <code>Set Identity</code> to submit the transaction.</p>
<p>Now Users have set the identity information on-chain, but that is not verified yet, so they should see a little gray icon beside users name. </p>
<p align="center">
<img src="registrar/./registrar3.png" alt="litentryReggistrar" width="40%" height="40%"/></p>
<p align="center">Figure 1.3 Account Example</p>
<p>It is the time to interact with the Litentry's verification bot by submitting the judgment request to the Litentry Registrar.</p>
<h3 id="judgement-request-1"><a class="header" href="#judgement-request-1">Judgement Request</a></h3>
<p>Go to Developer-&gt;Extrinsic and select your account to submit the identity -&gt; requestJudgement(reg_index, max_fee) transaction. This will request the registrar to validate the information you set on-chain earlier. The reg_index is the index of the registrar. For Litentry, use 4. The max_fee is the amount KSM to pay the registrar. Litentry Registrar service fee is 0.04 KSM.</p>
<p align="center">
<img src="registrar/./registrar5.png" alt="litentryReggistrar" width="75%" /></p>
<p align="center">Figure 1.4 Judgement request</p></center>
<h3 id="verification-services-1"><a class="header" href="#verification-services-1">Verification Services</a></h3>
<p>Since we provide the Email, Element and Twitter verification in our registrar at this moment, you will receive verification requests from those platforms. </p>
<h4 id="email-verification-1"><a class="header" href="#email-verification-1">Email Verification</a></h4>
<p>Users will receive an email called &quot;Litentry Verification Service&quot;. Figure 1.5 is an example of email verification. Users only need to click the button &quot;Verify Email Now&quot; to complete proof of email address. Then they will receive another confirmation email that shows the email has been verified successfully.</p>
<p align="center">
<img src="registrar/./email.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.5 Email Verification Example
</p>
<h4 id="element-verification-1"><a class="header" href="#element-verification-1">Element Verification</a></h4>
<p>As for Element, an invitation will be sent from the bot named &quot;litentry-bot&quot;. Once the user accepts the invitation, &quot;litentry-bot&quot; will send a verification link. Users only need to click the link to complete verification of the element account. When it proves the user is the account owner, they will receive a confirmation message such as &quot;Verified successfully&quot; (see the figure below). </p>
<p align="center">
<img src="registrar/./riot.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.6 Element Verification Example
</p>
<h4 id="twitter-verification-1"><a class="header" href="#twitter-verification-1">Twitter Verification</a></h4>
<p>In the Twitter verification process, users need to follow the Litentry official registrar account, namely Litentry Registrar (@LitentryReg). Users could also set their accounts to receive any private conversation in their privacy settings. Otherwise, they cannot receive the message from the Litentry registrar. 
Litentry Registrar will send a direct message associated with a verification link to the user. Once the verification link is clicked, 
the verification of Twitter is completed, and you should receive a successful verification message. The following figure is an example of the Twitter account verification process.</p>
<p align="center">
<img src="registrar/./twitter.png" alt="litentryReggistrar" width="50%"/></p>
<p align="center">Figure 1.7 Twitter Verification Example
</p>
<p>If everything has been verified successfully, you would see your account verification status has been marked as &quot;reasonable&quot; with a green tick icon on the account. And congratulations! Your identity should now show as a green &quot;verified&quot; checkmark on Polkadot-JS Apps.</p>
<h2 id="registrar-fee-1"><a class="header" href="#registrar-fee-1">Registrar Fee</a></h2>
<p>It is important to notice that no KSM are sent to the registrar at any time. You should NOT send or transfer funds. When calling the requestJudgement, the registrar fee will be locked and put aside. It will be transferred to the registrar only after the registrar finishes the judgment job. After all, we are using a trustless system. The judgement fee of Litentry Registrar is 0.04KSM.</p>
<h1 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h1>
<p>Github Repository: <a href="https://github.com/litentry/litentry-registrar">https://github.com/litentry/litentry-registrar</a></p>
<p>In this document, we introduce the Judgement level and implementation details of the Litentry registrar. At this stage, the Litentry registrar takes four confidence levels as judgment levels. Furthermore, We’d like to support <code>KnownGood</code> with well-known KYC organizations in the future. In the implementation details section, the Litentry Registrar Architecture is presented that includes Validators, Event Listener, ProvideJudgement Service, and Database Service. We also introduce a secure method using JWT to construct the verification protocol.</p>
<h2 id="judgement-levels--criteria"><a class="header" href="#judgement-levels--criteria">Judgement Levels &amp; Criteria</a></h2>
<p>Officially, registrars on Kusama can provide the six levels of confidence for users’ identity:</p>
<ul>
<li><code>Unknown</code>: The default value, no judgement made yet.</li>
<li><code>Reasonable</code>: The data appears reasonable, but no in-depth checks (e.g. formal KYC process) were performed.</li>
<li><code>KnownGood</code>: The registrar has certified that the information is correct.</li>
<li><code>OutOfDate</code>: The information used to be good, but is now out of date.</li>
<li><code>LowQuality</code>: The information is low quality or imprecise, but can be fixed with an update.</li>
<li><code>Erroneous</code>: The information is erroneous and may indicate malicious intent.</li>
</ul>
<ul>
<li><code>FeePaid</code>: The judgement is requested by a user and the information is verifying in progress. </li>
</ul>
<p>Litentry registrar takes Unknown, Reasonable, OutOfDate, Erroneous as confidence levels, and clarifies criteria for  those judgement levels. </p>
<p>If a user’s <code>display name</code>, <code>email</code>, <code>twitter</code>, or <code>element(previously called riot)</code> is verified, Litentry registrar comfirms the user's identity as Reasonable. Furthermore, Litentry registrar will also keep track of users' identity to see whether it’s out of date or not regularly. If a user doesn’t verify his identity timely,  his identity will degrade to OutOfDate. If a user intends to attack litentry registrar, e.g. DDOS, Litentry registrar will provide judgement with Erroneous and refuses to provide a judgment for him in a specific period.</p>
<p>As for LowQuality, it makes no sense to provide such a judgment for a requested user as a final judgement. Litentry registrar will automatically provide further hints to guide the user to update his identity. After all the information is verified correctly, the user will receive Reasonable. In this way, a user can not only save his fee (since we only provide one judgement for him) but also save his time (since Litentry registrar will point out imprecise or low quality identity timely).</p>
<p>At the current phase, Litentry registrar doesn’t support providing a judgement level of KnownGood since it needs cooperation with third-party KYC services. We’d like to support it with well-known KYC organizations in the future.</p>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation Details</a></h2>
<p>The key components of the Litentry registrar are shown as follows. It mainly includes Validators, Event Listener, ProvideJudgement Service and Database Service. Figure1.1 presents the architecture of the Litentry registrar, and Figure1.2 shows the main workflow of the registrar.</p>
<p align="center"><img src="registrar/./registrar12.png" alt="litentryReggistrar" width="60%"/></p>
<p align="center">Figure 1.1 The Architecture of the Litentry Registrar</p>
<p>The Event Listener listens to all events coming from the Kusama chain. Once a JudgementRequested event is triggered on Kusama and the JudgementRequested indicates to use the Litentry registrar, the Event Listener service will invoke Validators starting the verification process. </p>
<p>At the current stage, the Validators consist of three verification services, Email, Element, and Twitter verification. After receiving the verification request from the Event Listener, the Validator will invoke those verification jobs. They will send a verification link to the users provided accounts and wait for user confirmation from their accounts. As soon as the user confirms all verification links, the ProvideJudgement service will complete the final step, providing judgement for the user. The implementation details will be introduced in the next section separately.</p>
<p>Once the user proves the ownership of the Email, Element, and Twitter account, the ProvedeJudgement service will send a JudgementGiven transaction on the Kusama to confirm the ownership of the accounts that the user provides.</p>
<p>The Database service will temporarily store users’ data, e.g. Kusama account, email, Element, and Twitter account, so that we can recover services from an unpredictable crash. After completing the verification service, those data will be removed from the server permanently.</p>
<p align="center">
<img src="registrar/./registrar13.png" alt="litentryReggistrar" width="55%" height="60%"/></p>
<p align="center">Figure 1.2  The main Workflow of Verification process
</p>
<h3 id="security-and-availability"><a class="header" href="#security-and-availability">Security and Availability</a></h3>
<p>We use JSON Web Token (JWT) to construct the verification protocol. A nonce and an ObjectID (comes from mongodb) are used to generate the JWT token to ensure security of the Litentry registrar. In this implementation, only the user who requests identity judgement, which implies his/her ownership of this Kusama account, will receive this encrypted token. Malicious users cannot construct this token because of an unknown encryption secret, since nonce and ObjectID  are encrypted. And the malicious user has no way to re-play the attacks. </p>
<p>On the other hand, the websocket (TCP connection) can be easily reset by the remote peer due to long-time idle. In this situation, the events from the Kusama would be never captured since the disconnection between them. To prevent this situation, we capture the events from the underlying websocket connection and reconnect to the Kusama automatically whenever it’s reset by the peer.</p>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li>https://wiki.polkadot.network/docs/en/learn-identity#kusama-registrars</li>
</ol>
<h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<blockquote>
<p>What is the common use case of the identity protocol?</p>
</blockquote>
<p>In our protocol, we basically analog most authorization scenarios into a common protocol with four elements: d1. Person or IoT devices Identity d2. Authorization d3. Member's who holds the Authorization d4. External data related to the Identity. Here the Authorization token is similar to the ERC721 standard but not the same, it could be used to help understand the idea. The common idea is that the authorization is a piece of data created by the d1. Person or IoT devices Identity and send to a d3. Member. The Specification of each d1. Person or IoT devices Identity will be saved as d4. External data. This ownership and specification could be proved by the whole network. </p>
<p>Take door lock for example: An Airbnb host could use a smart lock to issue the digital key on our protocol, the user who has Parity-Signer Wallet (for example) could fetch the token data (d2. Authorization) and send it to the lock by a p2p way (Bluetooth for example) for validation. The lock will interpret the token data with its own pre-defined interpreter function (on-chain or off-chain, still need to think), like how many time a user may enter, what is the entry duration. By this way, the d1 Person or IoT devices could be shared in a decentralized and a securer way. We suppose such kind of authorization would fit the normal business (hotel) and sharing economy very well.</p>
<blockquote>
<p>Why use non-fungible-token as key rather than a signed message, e.g. a message signed using the digital key and can be validated by the lock off-chain.</p>
</blockquote>
<p>Signing transaction way works in authorization and it is simple. The basic of token authorization model is to validate a piece of information which is sent by the owner. These pieces of messages could be encrypted in the transaction as a message memo, and even transfer to others with last message data include or using a UTXO model.</p>
<p>In comparison, The &quot;non-fungible-token way&quot; or &quot;ERC721 Standard way&quot; gives a state map of all the authorizations and identity of the IoT device or people. The advantages are:</p>
<ol>
<li>
<p>The relationship between d1. Person or IoT devices Identity d2. Authorization d3. Member's who holds the Authorization could be checked easily, and this is very useful in many scenarios. For example, in an apartment sharing business, the user could know how many keys (tokens) are existed for a certain lock at the moment and further check the ownership of all other keys (tokens). </p>
</li>
<li>
<p>Bulk transactions are more efficient and easy to update (even no need for loops). For example, an identity could easily recall all his authorized tokens, or updates existed tokens information.</p>
</li>
<li>
<p>A state explicitly shows the relationship and will be easy for understanding, and cross-chain programming. The further cross-chain function call will be based on the state information on different parachains.</p>
</li>
</ol>
<p>In addition, the off-chain validation is still possible since the proof of token could directly be the identity (hash) of the token, and its information is retrievable from the state map. User with this information could send it to an off-line validator. ( Or a compromise way is that a validator regularly syncs with blockchain for the tokens and owners of identity, or totally an online validator).</p>
<blockquote>
<p>why do we need a GraphQl server? Is it worth the trade-off (complexity, centralization) as opposed to requests being validated directly on chain?</p>
</blockquote>
<p>A GraphQl is basically an API server, we have two different views of its usage. </p>
<ol>
<li>
<p>In a short view, since currently there are not so many libraries like oo7 which can directly connect with Substrate Runtime and external IPFS storage. An API server will currently offer fast development and could be used as a good demo for application developers, it could be regarded as Infura on Ethereum.</p>
</li>
<li>
<p>In a long-run view, we supposed it could be a query server for historical and caching server, which could offer fast access for the historical data, good infographics from database, caching the data by event listeners and queries, and reduce the load of the blockchain. Though it is with tradeoffs and comprises to the decentralized architecture, the most important validation and issuing functions will still be accessible directly by Blockchain.</p>
</li>
</ol>
<p>So in summary, the GraphQl API server is a necessary-to-have thing, but whether to use it will be mostly chosen by the application developer. </p>
<blockquote>
<p>What is the difference between ID Chain and Lock Chain and the need for each?</p>
</blockquote>
<p>Litentry is aimed to offer a basic protocol and related framework, which could be used for fast application development. Both the ID chain and Lock chain are one application based on it. </p>
<p>The traits of these two chains are in the same protocol with slight differences. Take ID chain, for example, The registry could be the citizen offices in a different city. Permissions would be that the different Right bind with certain people, like (boolean value for over 18 age, int value for tax level, etc). Permissions could be assigned to only one Member, but a member could have more than one Permissions.</p>
<p>The same in lock chain is that the Locks are a list with all different kinds of lock, the lock owner who has the private key of the lock may issue the access right token to the member, like multiple entry token, or a one-day-pass token. A member could have a different token with different locks, but one token could be only assigned to one person.</p>
<p>Though there are similarity and difference based on the implementation of the protocol of different traits of parachain. The main difference between these parachains is that they have different cross-chain function based on that. The cross-chain function could be e.g. A insurance (which authorized insurance token) calculate the healthy insurance working permit of ID Chain; the Lock chain will issue the entry token of a shisha bar with validating the age on ID chain; A gym will offer a special membership token to the people who have the entry token of co-working space, etc. All these cross-chain issue and validation will be defined by the cross-chain function on different para chains with the same protocol.</p>
<p>In addition to that, separate these chains will gain the flexibility to different business scenarios by adding the parachain-scope function. For example, an IoT device Chain with temperature monitors of different locations. A value of all the registered temperature monitors on 24:00 every day could be harvest directly to external storage. But if a user wants to get a piece of detail information on a certain time, he needs to has an authorization token for querying that data. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
